### ------------------ ###
### --- ZSH CONFIG --- ###
### ------------------ ###
path_to_my_git="/home/diego/Documents/Git/"
#path_to_my_git="/home/dinepomu/sgoinfre/MyFiles_/git/"
### Colors
rst="\e[0m"
red="\e[1;31m"
green="\e[1;32m"
yellow="\e[1;33m"
blue="\e[1;34m"
magenta="\e[1;35m"
cyan="\e[1;36m"
gray="\e[1;30m"
white="\e[1;37m"
bold="\e[1m"
italic="\e[3m"
underlined="\e[4m"
strikethrough="\e[9m"






# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
### --- POWER LEVEL CONFIG --- ###
### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

### Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
### Initialization code that may require console input (password prompts, [y/n]
### confirmations, etc.) must go above this block; everything else may go below.
typeset -g POWERLEVEL9K_INSTANT_PROMPT=quiet
typeset -g POWERLEVEL9K_INSTANT_PROMPT=off
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi
### Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"
### To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
### Set name of the theme to load --- if set to "random", it will
### load a random theme each time Oh My Zsh is loaded, in which case,
### to know which specific one was loaded, run: echo $RANDOM_THEME
### See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="powerlevel10k/powerlevel10k"
### Which plugins would you like to load?
### Standard plugins can be found in $ZSH/plugins/
### Custom plugins may be added to $ZSH_CUSTOM/plugins/
### Example format: plugins=(rails git textmate ruby lighthouse)
plugins=(git wakatime)
source $ZSH/oh-my-zsh.sh







### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
### --- CUSTOM FUNCTIONS AND ALIAS --- #
### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

### Custom Shell functions
source ${path_to_my_git}ops-Mylibs/mytools/0_zsh/my_functions.zsh



#!/bin/zsh
# Zsh Aliases Configuration
# Source this file in your ~/.zshrc: source /path/to/zsh_aliases.zsh

# ============================================================================
# Python Aliases
# ============================================================================
alias py='python3'
alias python='python3'
alias pip='pip3'

# ============================================================================
# Directory Navigation
# ============================================================================
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# Quick directory navigation with pushd/popd
alias d='dirs -v | head -10'
alias 1='cd -'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'

# ============================================================================
# List Directory Contents
# ============================================================================
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias ls='ls --color=auto'
alias lh='ls -lh'
alias lt='ls -ltr'  # Sort by modification time

# ============================================================================
# Git Aliases
# ============================================================================
alias gs='git status'
alias ga='git add'
alias gaa='git add --all'
alias gc='git commit'
alias gcm='git commit -m'
alias gp='git push'
alias gl='git log --oneline --graph --decorate'
alias gla='git log --oneline --graph --decorate --all'
alias gd='git diff'
alias gds='git diff --staged'
alias gco='git checkout'
alias gb='git branch'
alias gba='git branch -a'
alias gpl='git pull'
alias gcl='git clone'
alias gst='git stash'
alias gstp='git stash pop'

# ============================================================================
# Grep with Colors
# ============================================================================
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# ============================================================================
# Safety Aliases (prompt before overwrite/delete)
# ============================================================================
alias cp='cp -i'
alias mv='mv -i'
alias rm='rm -i'

# ============================================================================
# System Information
# ============================================================================
alias df='df -h'
alias du='du -h'
alias duh='du -h --max-depth=1 | sort -h'
alias free='free -h'
alias psg='ps aux | grep -v grep | grep -i -e VSZ -e'
alias mem='free -h && sync && echo 3 | sudo tee /proc/sys/vm/drop_caches && free -h'

# ============================================================================
# Networking
# ============================================================================
alias ports='netstat -tulanp'
alias myip='curl -s ifconfig.me'
alias localip='ip addr show | grep "inet " | grep -v 127.0.0.1 | awk "{print \$2}"'
alias ping='ping -c 5'
alias fastping='ping -c 100 -s.2'

# ============================================================================
# Misc Utilities
# ============================================================================
alias c='clear'
alias h='history'
alias hg='history | grep'
alias path='echo -e ${PATH//:/\\n}'
alias reload='source ~/.zshrc'
alias week='date +%V'
alias timer='echo "Timer started. Stop with Ctrl-D." && date && time cat && date'

# ============================================================================
# Quick Edit Config Files
# ============================================================================
alias editzsh='${EDITOR:-nano} ~/.zshrc'
alias sourcezsh='source ~/.zshrc'

# ============================================================================
# Development Shortcuts
# ============================================================================
alias serve='python3 -m http.server'
alias jn='jupyter notebook'
alias dcu='docker-compose up'
alias dcd='docker-compose down'
alias dps='docker ps'
alias dpsa='docker ps -a'

# ============================================================================
# Functions
# ============================================================================

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Extract any archive
extract() {
    if [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"     ;;
            *.tar.gz)    tar xzf "$1"     ;;
            *.bz2)       bunzip2 "$1"     ;;
            *.rar)       unrar x "$1"     ;;
            *.gz)        gunzip "$1"      ;;
            *.tar)       tar xf "$1"      ;;
            *.tbz2)      tar xjf "$1"     ;;
            *.tgz)       tar xzf "$1"     ;;
            *.zip)       unzip "$1"       ;;
            *.Z)         uncompress "$1"  ;;
            *.7z)        7z x "$1"        ;;
            *.deb)       ar x "$1"        ;;
            *.tar.xz)    tar xf "$1"      ;;
            *.tar.zst)   unzstd "$1"      ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Quick find
qfind() {
    find . -name "*$1*"
}

# Backup file with timestamp
backup() {
    if [ -f "$1" ]; then
        cp "$1" "$1.backup.$(date +%Y%m%d_%H%M%S)"
        echo "Backup created: $1.backup.$(date +%Y%m%d_%H%M%S)"
    else
        echo "File not found: $1"
    fi
}

# Create a new directory and enter it
mkd() {
    mkdir -p "$@" && cd "$_"
}

# Get current git branch
git_current_branch() {
    git branch 2>/dev/null | sed -n '/\* /s///p'
}

# Quick git commit with message
gcam() {
    git add --all && git commit -m "$1"
}

# Quick git push to current branch
gpsh() {
    git push origin $(git_current_branch)
}

echo "Zsh aliases loaded successfully!"


alias mem_recover=/home/diego/Documents/Git/mylibs/mytools/0_unix/kill_halt.sh

alias gdrive='bash /home/diego/Documents/Git/mylibs/mytools/0_unix/rclone_mount.sh'
alias gdrive_mount='bash /home/diego/Documents/Git/mylibs/mytools/0_unix/rclone_mount.sh'
alias gdrive_umount='fusermount -u /home/diego/Documents/Gdrive'

alias py='python3'
export PATH="/home/diego/.local/bin:$PATH"
alias python python3
alias py python3
alias pip pip3




### FUNCTIONS
function pyp() {
    # 1. Check for minimum arguments
    if [[ $# -lt 1 ]]; then
        echo "Error: Need at least one argument: [Package_Name] or [sudo Package_Name]."
        return 1
    fi

    # Variables
    local is_sudo_mode=false
    local target_package=""
    # We will use an array to hold extra args to handle spaces correctly
    local -a extra_args

    # --- Mode Detection ---
    if [[ "$1" == "sudo" ]]; then
        # MODE: SUDO (e.g., pyp sudo ps_mem)
        if [[ $# -lt 2 ]]; then
            echo "Error: 'pyp sudo' requires a package name: pyp sudo [package]."
            return 1
        fi
        is_sudo_mode=true
        target_package="$2"
        # Get all arguments starting from the 3rd one
        extra_args=("${@:3}")
    else
        # MODE: STANDARD (e.g., pyp ps_mem)
        target_package="$1"
        # Get all arguments starting from the 2nd one
        extra_args=("${@:2}")
    fi

    # 2. Change Directory
    # We use '|| return' to stop if the folder doesn't exist
    cd ~/sys/poetry_venv_1 || { echo "Error: Project directory not found."; return 1; }

    # 3. INSTALL the package (Always runs)
    echo "Installing package: $target_package..."
    poetry add "$target_package"

    # 4. RUN the command
    echo "Running command..."

    if [[ "$is_sudo_mode" == "true" ]]; then
        # --- SUDO PATH FIX ---

        # Get the absolute path dynamically from the Venv
        # 2>/dev/null hides error messages if 'which' fails
        local abs_path=$(poetry run which "$target_package" 2>/dev/null)

        if [[ -z "$abs_path" ]]; then
            echo "Error: Could not find executable '$target_package' in Venv."
            return 1
        fi

        # Join arguments into a string.
        # (j: :) joins the array elements with a space.
        local args_string="${(j: :)extra_args}"

        # Build the final command string: sudo "/path/to/exe" arg1 arg2
        local command_string="sudo \"$abs_path\" $args_string"

        echo "Executing with SUDO path fix: sh -c '$command_string'"

        # Execute via sh -c to handle sudo correctly
        poetry run sh -c "$command_string"
    else
        # --- STANDARD EXECUTION ---
        # We pass the array "${extra_args[@]}" to preserve argument integrity
        poetry run "$target_package" "${extra_args[@]}"
    fi
}


### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
### --- CUSTOM FUNCTIONS AND ALIAS --- # FOR C
### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
### MYHELPER
function myhelp {
	printf "\n\n\n$green##########################"
	printf "\n$green####### MYHELPER #########"
	printf "\n$green##########################$rst\n"
	printf "\n$underlined Functions sh List:$rst"
	printf "\n * c, cx, cv, cdb"
	printf "\n * cl, clx, clv, cldb, cldbg"
	printf "\n * ce"
	printf "\n * code_cleaner, clean_debuger, file_consol_lns"
	printf "\n * ansi_colors\n"
	printf "\n$underlined Syntaxes:$rst"
	printf "\n Compile, Include Lib and Execute:$rst"
	printf "\n$bold  clx <source.c> [args...]$rst\n"
	printf "\n Compile, Include Lib and Varlgrind:$rst"
	printf "\n$bold  clv <source.c> {test_name|-} {infile_stdin|-} [args...]$rst\n"
	printf "\n Compile, Include Lib and Debug:$rst"
	printf "\n$bold  cldb <source.c> [args...]$rst\n"
}

### COMPILERS no LIB
# --- Compile FILES
function c {
	clang -g3 "$@" -o "$(basename "$1" .c).out"
}

# --- Compile FILE+ARG and Execute
function cx {
  clang -g3 "$1" -o "$(basename "$1" .c).out"
  ./"$(basename "$1" .c).out" "${@:2}"
}

# --- Compile FILE+ARG with Library and Execute
### cv [file.c] - - [args]
### or
### cv [file.c] [test_name] [infile_stdin] [args]
### 	$1		$2			$3				$4
function cv {
### Variables
	if [[ "$1" = "help" ]]; then
		echo -e "\n$yellow##########################"
		echo -e "####### CV HELP ###########"
		echo -e "##########################$rst\n"
		echo -e "$underlined Syntax:$rst"
		echo -e "$bold cv <source.c> {test_name|-} {infile_stdin|-} [args...]$rst\n"
		echo -e "$underlined Examples:$rst"
		echo -e " cv file.c - - arg1"
		echo -e "  or"
		echo -e " cv file.c crazy_input log/infile_stdin arg1 arg2 arg3"
		echo -e "\n$underlined Notes:$rst"
		echo -e "$gray<> mandatory, [] optional, {|} mutually exclusive, ... expandable$rst"
		echo -e "\n"
		return
	fi
	source_file=$1
	test_name=$2
	if [[ "$2" == '-' ]]; then
		test_name=$4
	fi
	infile_stdin="$3"
	args="${@:4}"

	valg_filename="log/valgrind_$test_name.log"
	valg_outfile="--log-file=$valg_filename"

	valg_flags_fd="--track-fds=yes"
	valg_flags_fork="--trace-children=yes"

	valg_flags_memcheck="-s --leak-check=full --show-leak-kinds=all --track-origins=yes --show-mismatched-frees=yes"
	valg_memcheck="$valg_outfile $valg_flags_memchk $valg_flags_fd $valg_flags_fork"

	valg_threads2="--tool=threadcheck"
	valg_threads1="--tool=drd"
	valg_threads0="--tool=helgrind"
	valg_threads=$valg_threads0
	valg_threads="$valg_outfile $valg_threads $valg_flags_fd $valg_flags_fork"

	program="./$(basename "$source_file" .c).out"
	outfile_stdout="log/outfile_$test_name.log"
	std_out="$outfile_stdout 2>&1 ; echo \"\nReturn: $?\" >> $outfile_stdout 2>&1"


	red="\e[1;31m"
	rst="\e[0m"

### Main
#### Compile
	clang -g3 $source_file -o "$(basename "$source_file" .c).out"

#### Execute Valgrind
	mkdir -p log
	if [[ "$infile_stdin" == '-' ]]; then
		eval "valgrind ${valg_memcheck} ${program} ${args} > ${std_out}"
	else
		eval "valgrind ${valg_memcheck} ${program} ${args} < ${infile_stdin} > ${std_out}"
	fi
	echo -e "\n==      == PROGRAM INPUT ===\n" >> $valg_filename ; echo "$args\n" >> $valg_filename
	echo -e "\n==      == PROGRAM OUTPUT ===\n" >> $valg_filename ; cat $outfile_stdout >> $valg_filename

#### Print Valgrind Report
	echo -e "\n\n\n$red##########################"
	echo -e "##### Valgrind Test #######"
	echo -e "##########################$rst\n"

	echo "\n$red=== PROGRAM OUTPUT ===$rst"
	grep -A 4 "PROGRAM OUTPUT" $valg_filename

	echo "\n$red=== HEAP SUMMARY ===$rst"
    grep -A 4 "HEAP SUMMARY" $valg_filename

	echo "\n$red=== LEAK SUMMARY ===$rst"
    grep -A 7 "LEAK SUMMARY" $valg_filename

	echo "\n$red=== FILE DESCRIPTORS ===$rst"
    grep -A 0 "FILE DESCRIPTORS" $valg_filename

	echo "\n$red=== ERRORS ===$rst"
	grep -B 1 -A 2 "at 0x" $valg_filename

}

# --- Valgrind Test Generator using cv function, each line of the while be parsed using sed or awk to be a input for cv function
function cv_test {
	# --- Variables
	source_file="$1"
	infile_test="$2"

	# --- Main
	echo -e "== VALGRIND TEST ===\n\n"

	while read -r args; do
		cv $source_file $args
	done < $infile_test
}


### COMPILERS WITH LIB
# --- Compile FILES with Library
function cl {
	lib_header="${path_to_my_git}mylibs/mylibc/inc"
	lib_addss="${path_to_my_git}mylibs/mylibc"
	lib_name="mylibc"
	clang -g3 "$1" -I"${lib_header}" -L"${lib_addss}" -l"${lib_name}" -o "$(basename "$1" .c).out"
	./"$(basename "$1" .c).out" "${@}"
}

# --- Compile FILE+ARG with Library and Execute
function clx {
	lib_header="${path_to_my_git}mylibs/mylibc/inc"
	lib_addss="${path_to_my_git}mylibs/mylibc"
	lib_name="mylibc"
	clang -g3 "$1" -I"${lib_header}" -L"${lib_addss}" -l"${lib_name}" -o "$(basename "$1" .c).out"
	./"$(basename "$1" .c).out" "${@:2}"
}

# --- Compile FILE+ARG with Library and Execute
function clv {
#Variables
	lib_header="${path_to_my_git}mylibs/mylibc/inc"
	lib_addss="${path_to_my_git}mylibs/mylibc"
	lib_name="mylibc"
	valg_args="--leak-check=full --show-leak-kinds=all --track-origins=yes -s --log-file=valgrind_output.txt"
	program="./$(basename "$1" .c).out"
	output=" > /dev/null 2>&1"
	input="${@:2}"
#Main
	clang -g3 "$1" -I"${lib_header}" -L"${lib_addss}" -l"${lib_name}" -o "$(basename "$1" .c).out"
	eval "valgrind ${valg_args} ${program} ${output} ${input}"
	grep "$1": valgrind_output.txt
}



### DEBUG
# --- LLDB
function cdb {
	echo -e "\n\n\n################################################################"
	echo -e "##### CLANG LLDB #####################################################"
	echo -e "# b main or b [function_name]\t# Set a breakpoint at the start of the 'main' function"
	echo -e "# r\t\t# Run the program"
	echo -e "# "
	echo -e "# s\t\t# Step over the current line (execute it as one step)"
	echo -e "# finish\t\t# Step out of the current function"
	echo -e "# "
	echo -e "# n\t\t# Step into the next line (enter functions if called)"
	echo -e "# "
	echo -e "# v\t\t# View all local variables (useful after hitting a breakpoint)"
	echo -e "# bt\t\t# View the current call stack"
	echo -e "# "
	echo -e "# c\t\t# Continue execution after hitting a breakpoint"
	echo -e "# "
	echo -e "# gui\t\t# Launch the LLDB graphical user interface (full screen)"
	echo -e "#######################################################################\n\n"
	output_name="$(basename "$1" .c)_dbD.db.out"
	clang -g3 "$1" -l"${lib_name}" -o "${output_name}"
	lldb ./"${output_name}" "${@:2}" -o "b main" -o "run" -o "v"
}

# --- CLANG_LLDB
function cldb {
	echo -e "\n\n\n################################################################"
	echo -e "##### CLANG LLDB #####################################################"
	echo -e "# b main or b [function_name]\t# Set a breakpoint at the start of the 'main' function"
	echo -e "# r\t\t# Run the program"
	echo -e "# "
	echo -e "# s\t\t# Step over the current line (execute it as one step)"
	echo -e "# finish\t# Step out of the current function"
	echo -e "# "
	echo -e "# n\t\t# Step into the next line (enter functions if called)"
	echo -e "# "
	echo -e "# v\t\t# View all local variables (useful after hitting a breakpoint)"
	echo -e "# bt\t\t# View the current call stack"
	echo -e "# "
	echo -e "# c\t\t# Continue execution after hitting a breakpoint"
	echo -e "# "
	echo -e "# gui\t\t# Launch the LLDB graphical user interface (full screen)"
	echo -e "#######################################################################\n\n"
	output_name="$(basename "$1" .c)_dbD.db.out"
	lib_header="${path_to_my_git}mylibs/mylibc/inc"
	lib_addss="${path_to_my_git}mylibs/mylibc"
	lib_name="mylibc"
	clang -g3 "$1" -I"${lib_header}" -L"${lib_addss}" -l"${lib_name}" -o "${output_name}"
	lldb ./"${output_name}" "${@:2}" -o "b main" -o "run" -o "v"
}

# --- GCC_GDB
function cldbg {
	echo -e "\n\n\n################################################################"
	echo -e "##### GCC GDB #####################################################"
	echo -e "# b main or b [function_name]\t# Set a breakpoint at the start of the 'main' function"
	echo -e "# r\t\t# Run the program"
	echo -e "# "
	echo -e "# s\t\t# Step INTO the current line (execute it as one step)"
	echo -e "# finish\t\t# Step OUT of the current function"
	echo -e "# "
	echo -e "# n\t\t# Step OVER to the next line (enter functions if called)"
	echo -e "# "
	echo -e "# info locals\t\t# View all local VARIABLES (useful after hitting a breakpoint)"
	echo -e "# info frame \t\t# View all local VARIABLES (useful after hitting a breakpoint)"
	echo -e "# info args\t\t# View all ARGUMENTS (useful after hitting a breakpoint)"
	echo -e "# bt\t\t# View the current call stack"
	echo -e "# "
	echo -e "# c\t\t# CONTINUE execution after hitting a breakpoint"
	echo -e "# "
	echo -e "# gdb -tui your_program"
	echo -e "# tui enable"
	echo -e "#######################################################################\n\n"
	output_name="$(basename "$1" .c)_dbD.db.out"
	lib_header="${path_to_my_git}mylibs/mylibc/inc"
	lib_addss="${path_to_my_git}mylibs/mylibc"
	lib_name="mylibc"
	gcc -g3 "$1" -I"${lib_header}" -L"${lib_addss}" -l"${lib_name}" -o "${output_name}"
	gdb ./"${output_name}" "${@:2}" -ex "b main" -ex "run" -ex "info locals"
}


### MAKE UTILS
# --- CODE CLEANER
function code_cleaner {
	folder="${path_to_my_git}libft_xtend/ft_mylib/src/9_Quality_Assurance/Code_Cleaner"
	file="clean_code.sh"
	"$folder/$file" "$@"
}

# --- CODE CLEANER
function clean_debuger {
	folder="${path_to_my_git}mylibs/mytools/1_coding/make_utils"
	file="clean_debuger.sh"
	"$folder/$file" "$@"
}

# --- Search Recursively and Consolidate with Symb Link
function file_consol_lns {
	folder="${path_to_my_git}mylibs/mytools/1_coding/make_utils"
	file="files_lns.sh"
	"$folder/$file" "$@"
}





### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
### --- STARTUP SERVICES --- #
### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

### RCLONE
### Check if the Gdrive is mounted by looking for it in the mount outpu. '-q' is silent no output.
if ! mount | grep -q "/home/diego/Documents/Gdrive"; then
	bash /home/diego/Documents/Git/mylib/mytools/0_unix/rclone_mount.sh
fi














### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
### --- STARTER SCREEN --- #
### # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

### STARTER SCREEN
### Clear
clear
clear
### Function to fetch and format system info
function get_system_info {
  local os_name=$(uname -s)
  local kernel_version=$(uname -r)
  local hostname=$(hostname)
  local uptime=$(uptime | awk '{print $3, $4}' | sed 's/,//')
  local cpu_model=$(lscpu | grep "Model name:" | awk '{print $3,$4,$5,$6,$7,$8}')
  local memory_usage=$(free -h | awk '/Mem:/ {printf "%.1f GB / %.1f GB", $3/1024/1024, $2/1024/1024}')

  echo -e "\n1.System Information:"
  echo -e "------------------"
  echo -e "OS:\t\t$os_name"
  echo -e "Kernel:\t\t$kernel_version"
  echo -e "Hostname:\t$hostname"
  echo -e "Uptime:\t\t$uptime"
  echo -e "CPU:\t\t$cpu_model"
  echo -e "Memory:\t\t$memory_usage"
}

### Function to fetch and format network info
function get_network_info {
  local ip_address=$(ip addr show eth0 | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)  # Adjust 'eth0' if needed
  local gateway=$(ip route | grep default | awk '{print $3}')

  echo -e "\n2.Network Information:"
  echo -e "-------------------"
  echo -e "IP Address:\t$ip_address"
  echo -e "Gateway:\t$gateway"
}

### Function to fetch and format disk usage
function get_disk_usage {
  local disk_usage=$(df -h / | awk 'NR==2 {printf "%s / %s (%.1f%%)", $3, $2, $5}')

  echo -e "\n3.Disk Usage:"
  echo -e "-----------"
  echo -e "Root:\t\t$disk_usage"
}

### --- Main screen output ---

### Header
echo -e "\e[1;34mWelcome to your shell, $(whoami)!\e[0m"  # Blue color
date +"%A, %B %d, %Y - %I:%M %p"

### System, Network, and Disk Info
get_system_info
get_network_info
get_disk_usage

### Optional: Add more sections for other data (e.g., weather, calendar, news)
echo -e "\n4.Rclone - Mounted Drives"
echo -e "-----------------------"
mount | grep Gdrive

### Footer
echo -e "\n\e[32mHave a productive day!\e[0m"  # Green color

### ... (header and other sections) ...

### ART
echo_with_art() {
  ### Print the ASCII art
  cat << 'EOF'

           _               _
       _  /\ \           /\ \
      /\_\\ \ \         /  \ \
     / / / \ \ \       / /\ \ \
    / / /   \ \ \      \/_/\ \ \
    \ \ \____\ \ \         / / /
     \ \________\ \       / / /
      \/________/\ \     / / /  _
                \ \ \   / / /_/\_\
                 \ \_\ / /_____/ /
                  \/_/ \________/


EOF

  ### Print the arguments passed to the function
  echo "$@"
}

### Call the function
echo_with_art

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# Chrome without CORS restrictions (for local HTML tools)
alias chrome_no_CORS="chromium --disable-web-security --user-data-dir=/tmp/chrome-dev"
alias chromium_no_CORS="chromium --disable-web-security --user-data-dir=/tmp/chrome-nocors"
alias brave_no_CORS="brave --disable-web-security --user-data-dir=/tmp/brave-nocors"
alias ppy="poetry run python3"

# CPU capacity check
cpucap() {
  for i in /sys/devices/system/cpu/cpu[0-7]/cpufreq; do
    cur=$(cat $i/scaling_cur_freq)
    max=$(cat $i/scaling_max_freq)
    core=$(basename $(dirname $i))
    printf "%s: %4d MHz / %4d MHz = %3d%%\n" $core $((cur/1000)) $((max/1000)) $((cur*100/max))
  done
}
export PATH="$HOME/.local/bin:$PATH"
export DBX_CONTAINER_MANAGER=docker
